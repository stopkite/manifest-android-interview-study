### SparseArray란

- HaspMap과 유사하게 정수 키를 객체 값에 매핑하는 데이터 구조
- 정수 키를 사용하는 상황에서, Java/Kotlin 의 Map이나 HashMap보다 메모리 효율성이 좋고 상황에 따라 성능이 더 좋을 수 있다.

### SparseArray의 주요 특징

- 메모리 효율성
    - 키-값 매핑을 위해 HashTable을 사용하는 HashMap과 달리, SparseArray는 int를 Integer로 매핑하는 오토박싱을 피하고 Entry 객체와 같은 추가 데이터 구조에 의존하지 않아 훨씬 더 적은 메모리를 소비
- 성능
    - 내부적으로 이진탐색을 사용하기 때문에 데이터의 규모가 큰 경우에는 HashMap보다는 느리지만, 메모리 최적화 덕분에 중간 크기의 데이터 셋에서 더 나은 성능을 제공
- Null 키 값 사용 불가
    - SparseArray는 기본적으로 정수를 키로 사용하므로 null 키 값을 허용하지 않음

### SparseArray 사용의 이점

- 오토박싱 방지
    - HashMap의 경우 키가 Integer 객체로 매핑되어 저장되므로 추가적인 메모리 및 계산 작업이 수행되는 반면, SparseArray는 int를 직접 key로 등록하기에 메모리 및 계산을 절약할 수 있음
- 메모리 절약
    - 위 오토박싱과 더불어 SparseArray는 내부적으로 여러 객체를 생성하는 HashMap과 비교하여 더 적은 메모리 공간을 차지함
- 컴팩트한 데이터 저장에 효율적
    - 적은 수의 키-값 쌍이 있는 밀도가 낮은 데이터셋이나 키가 넓은 정수 범위에 걸쳐 Sparse하게 분포된 데이터 셋에 적합
- 안드로이드 특화
    - 제한된 리소스 시나리오를 처리하기 위해 안드로이드에 특화된 구조로 설계되어, 안드로이드 UI 컴포넌트에서 View ID를 객체에 매핑하는 등의 시나리오에 효과적

### SparseArray의 한계

- 성능 트레이드오프
    - SparseArray는 키에 대한 값을 조회할 때 이진 탐색을 수행하기 때문에 매우 큰 데이터셋의 경우 HashMap보다 느리다.
    - 정수 키만 사용 가능

### Q. HashMap 대신 SparseArray를 사용하는 것이 어떤 시나리오에서 더 효율적이며, 성능 및 사용성 측면에서 트레이드오프는 무엇인가요?

- HashMap과는 다른 SparseArray의 특징 덕에, 아래 시나리오에서 더 효율적으로 사용할 수 있을 것으로 보인다.
    - HashMap과 달리 Integer 래핑, Entry같은 부가적인 객체 생성이 없어 메모리를 더 적게 사용하므로, 메모리 효율성이 중요한 경우
    - 데이터의 크기가 작거나, 중간 정도인 경우 
    (logN 시간복잡도가 상수에 가까운 정도, 수백 ~ 수천개)
    - 갑을 순회할 시 key 순서대로 순회되지 않는 HashMap과는 달리, SparseArray는 int 키 값을 정렬하여 관리하므로(삽입시에도 이진 탐색을 사용) 값 전체를 순서를 보장하며 순회하는 작업이 필요한 경우
- 자료구조에서 많이 사용되는 조회/삽입/삭제별 성능 측면을 비교하면
    - 조회
        - 상수 시간 O(1)인 HashMap과는 달리, SparseArray는 O(log N)의 시간 복잡도를 가진다.
    - 삽입
        - 상수 시간 O(1)인 HashMap과는 달리, SparseArray는 내부적으로 새 Array를 제작하는데 O(N)이 소요될 수 있다.
    - 삭제
        - 상수 시간 O(1)인 HashMap과는 달리, SparseArray는 내부적으로 gc() 메서드를 호출하지 않는다면 O(log N), 만약 gc() 메서드를 호출한다면 O(N)의 시간복잡도를 가진다.

### 내부 구조

- 내부적으로는 key들의 배열(int[] mKeys), value들의 배열을 가지고 있다.(object[] mValues)
- 데이터를 저장하는 put 메서드의 대략적인 과정은 아래와 같다.
    1. 인자로 전달받은 key의 mKeys상 index를 리턴한다 (이진탐색)
        - 만약 key가 존재하는 경우, 해당 key의 index를 리턴
        - 만약 key가 존재하지 않은 경우, 해당 key가 주입되어야 하는 index에 bitwise NOT을 적용한 값을 리턴한다.
            - 만약 key가 들어가야 할 index가 2라면, ~2(=-3)을 리턴한다.
    2. index가 양수/음수인지에 따라 아래 로직을 수행한다
        1. index가 양수인 경우, mValues[index]에 value를 할당한다.
        2. index가 음수인 경우, ~index를 사용하여 key가 들어가야 할 index를 복원하고,
        해당 index 자리에 key, value가 들어간 새 배열을 생성하여 mKeys, mValues에 할당한다.
- 즉, 데이터를 추가할 때마다 새 배열을 생성하는 과정이 발생한다.
만약 별다른 로직을 수행하지 않는다면 데이터를 삭제하는 경우에도 동일하게 해당 key, value가 제거된 새 배열을 생성한 후 mKeys, mValues에 할당하는 과정을 거쳤겠지만
    - SparseArray에서 값을 삭제할 때는 key, value를 mKeys, mValues에서 지우는 방식 대신, mValues에 할당된 값을 DELETED라는 객체로 대신 넣어둔다.
    - 이는 위에서도 언급했듯, 값을 지울 때마다 매번 배열을 새로 생성하는 작업을 최소화하기 위함이다.
    - DELETED로 할당된 부분은 내부 private 함수인 gc()라는 메서드를 호출할 때 한번에 처리된다.