## Serializable과 Parcelable의 차이점
- Serializable
  - Java 표준 인터페이스로, 특정 플랫폼에 종속되지 않음
  - Java 리플렉션을 기반으로 하여 시스템이 런타임 도중 클래스와 필드를 동적으로 검사
    - 리플렉션을 사용하기 때문에 Parcelable에 비해 느리며, 리플렉션을 사용한 직렬과 여러 임시 객체를 생성하므로 메모리 오버헤드가 발생한다.

- Parcelable
  - 안드로이드 컴포넌트 내에서 IPC를 위해 특별히 설계된 안드로이드 기반 인터페이스
  - 개발자가 직접 어떻게 직렬화를 수행하고(writeToParcel) 어떻게 역직렬화를 수행하는지(Parcelable.Createor.createFromParcel) 명시해야 하기 때문에, 리플렉션에 의존하지 않고 안드로이드에 최적화되어 있어 Serializable에 비해 빠르며 임시 객체 생성을 피할 수 있음
  - `kotlin-parcelize` 플러그인 사용시 writeToParcel, createFromParcel을 직접 구현할 필요 없이 플러그인에서 자동으로 해당 구현을 생성해준다.

``` kotlin
data class User(val id: Int, val name: String) : Parcelable {
    constructor(parcel: Parcel) : this(
        parcel.readInt(),
        parcel.readString() ?: ""
    )
 
    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeInt(id)
        parcel.writeString(name)
    }
 
    override fun describeContents(): Int = 0
 
    companion object CREATOR : Parcelable.Creator<User> {
        override fun createFromParcel(parcel: Parcel): User {
            return User(parcel)
        }
 
        override fun newArray(size: Int): Array<User?> {
            return arrayOfNulls(size)
        }
    }
}
```

- Serializable에서 발생하는 임시 객체?
  - Serializable 클래스에 대해 직렬화를 수행할 때는 먼저 getClass를 통해 해당 클래스가 어떤 클래스인지 여부를 확인한다.
  - 이후 해당 클래스에 어떤 변수가 존재하는지를 clazz.getDeclaredFields를 사용하여 가져오는데, 이 때 각 변수를 Field라는 객체를 생성하여 가져오게 된다.
  (getDeclaredFields의 리턴 타입이 Field[])
  - 또한 field.getName, getType과 같은 메서드를 사용하여 해당 변수의 세부 정보를 조회하는데 이 과정에 있어서도 내부적으로 추가 객체들이 생성될 수 있다.

## Parcelable 사용시 주의점
- Parcelable로 선언된 클래스의 프로퍼티 중, Primitive가 아니면서 동시에 Parcelable이 아닌 클래스가 존재한다면, 아래 에러가 발생한다.
`Type is not directly supported by ‘Parcelize’. Annotate the parameter type
with ‘@RawValue’ if you want it to be serialized using ‘writeValue()’.`
이는 Parcelize 컴파일러 플러그인이 직렬화를 수행할 수 없어 발생한 문제로, 문제가 발생한 프로퍼티를 Parcelable이 되도록 수정해야 한다.
- Parcelable의 경우 안드로이드 버전에 따라 내부 구현이 변경될 수 있으므로, Parcelable을 통해 직렬화된 데이터를 SharedPreference와 같은 로컬 데이터베이스에 저장하는 것은(= 유지기간이 긴 데이터) 부적합하다.

## Q. 안드로이드에서 Serializable과 Parcelable의 차이점은 무엇이며, 일반적으로 컴포넌트간 데이터 전달에 Parcelable이 선호되는 이유는 무엇인가요?
- Serializable의 경우 직렬화/역직렬화를 JVM에게 맡기며 리플렉션을 사용하여 작업을 수행한다.
이로 인해 수행 시간이 더 오래 걸리며 추가적인 임시 객체가 생성되어 메모리 오버헤드가 발생할 수 있다.
- 반면 Parcelable의 경우 개발자가 직접 writeToParcel, createFromParcel을 구현하여 별도로 클래스 및 내부 프로퍼티를 검사할 필요가 없으며, 이 덕분에 리플렉션을 사용하지 않아 소요 시간이 줄고 임시 객체의 생성을 막을 수 있다.