## Fragment 생명주기
1. onAttach
- Fragment가 Activity에 연결될 떄 호출
- 이 시점부터 Activity와 상호작용이 가능

2. onCreate
- Fragment가 생성될 때 호출되며, Activity의 onCreate처럼 객체를 초기화하거나 savedInstanceState을 통해 데이터를 복원하는 작업을 수행할 수 있다.

3. onCreateView
- Fragment의 UI가 처음으로 그려질 때 호출되며, LayoutInflater를 사용하여 Fragment의 레이아웃을 인플레이션하는 메서드
- 이 시점에서 Fragment 레이아웃의 루트 뷰를 리턴

``` kotlin
override fun onCreateView(
    inflater: LayoutInflater, container: ViewGroup?,
    savedInstanceState: Bundle?
): View {
    // 1. XML 레이아웃을 인플레이트하고 binding 객체 생성
    _binding = FragmentSampleBinding.inflate(inflater, container, false)
    
    // 2. binding 객체를 통해 UI 요소에 접근
    binding.myTextView.text = "Hello, Fragment!"
    
    // 3. 생성된 최상위 뷰(root)를 리턴
    return binding.root
}
```

4. onViewCreated
- Fragment의 뷰가 생성된 이후 호출

5. onViewStateRestored
- Fragment의 뷰 계층이 생성되고 저장된 상태가 뷰에 복원될 떄 호출

6. onStart
- Fragment가 사용자에게 표시될 떄 호출되지만, 아직 상호작용은 불가능한 상태

7. onResume
- Fragment가 foreground에 존재하며 사용자와 상호 작용 가능할 떄 호출

8. onPause
- Fragment가 foreground에 존재하지는 않지만 여전히 사용자에게는 표시될 때 호출
- Fragment가 포커스를 잃기 직전에 호출되며 foreground에서 지속되면 안되는 작업을 일시 중지해야 함

9. onStop
- Fragment가 더 이상 사용자에게 표시되지 않을 떄 호출

10. onSaveInstanceState
- Fragment가 소멸되기 전에 UI관련 상태 데이터를 저장하기 위해 호출
- 추후 onViewStateRestored를 통해 저장한 상태를 기반으로 UI 관련 상태를 복원

11. onDestroyView
- Fragment 뷰 계층이 제거될 떄 호출
- 뷰와 관련된 리소스를 해제해야 함

``` kotlin
override fun onDestroyView() {
    super.onDestroyView()
    // 뷰 참조를 null로 설정하여 메모리 누수를 방지
    _binding = null
}
```

12. onDestroy
- Fragment가 소멸될 때 호출되며 개발자가 직접 해제가 필요한 리소스에 대해 해제하는 작업을 수행해야 함
- 단, 아직 Activity에 연결되어 있음

13. onDetach
- Fragment가 Activity로부터 분리되며, Fragment의 생명주기 마지막

## Q. onCreateView()와 onDestroyView()의 목적은 무엇이며, 해당 메서드에서 뷰 리소스를 올바르게 처리하는 것이 왜 중요한가요?
- onCreateView는 View를 생성하는 것이 목적으로, Fragment가 화면에 표시할 UI 레이아웃을 생성하여 시스템에 반환하는 기능을 수행한다.
- onDestroyView는 onCreateView에서 만들었던 UI와 관련된 모든 리소스를 정리하는 것이 목적으로, 더 이상 화면에 보이지 않는 View와 관련된 참조를 모두 해제하는 기능을 수행한다.
- Fragment에서 뷰 계층 생명주기는 Fragment 생명주기보다 짧으므로, 만약 뷰 계층 생명주기에 맞추어 뷰 리소스를 처리하지 않는다면 뷰 계층이 소멸되었음에도 불구하고 Fragment에서 이를 호출함으로써 예상치 못한 예외가 발생할 수 있고 더 이상 사용하지 않는 뷰 계층에 대한 참조를 유지함으로써 메모리 누수가 발생할 수 있다.

## FragmentManager와 ChildFragmentManager의 차이점은 무엇인가요?
- Fragment는 Activity 수준에서 동작하며 Activity에 직접 연결된 Fragment를 관리한다.
- ChildFragmentManager의 경우 Fragment 내에서 중첩된 Fragment를 관리하는데 사용된다.


## 왜 Activity에는 onCreateView와 같은 생명주기 메서드가 없을까?
- Activity의 경우에는 독립적인 화면을 이루는, 즉 UI를 나타내는 구성 요소
- Fragment의 경우 UI가 없는 로직만 담은 재사용 가능한 클래스로서 사용될 수 있기 때문
  - 이러한 부분으로 인해 Fragment는 Fragment 생명주기와 FragmentView의 생명주기가 분리되어 있다.

## Fragment의 viewLifecycleOwner 인스턴스
- Fragment는 Activity에 연결되어 자체적인 생명주기를 가지지만, Fragment의 뷰 계층은 이와 별도의 생명주기를 가진다.
- Fragment의 뷰 계층 생명주기는 Fragment 생명주가보다 짧으며, 이로 인해서 만약 Fragment 뷰 계층의 생명주기가 끝났음에도 Fragment의 생명주기에서 뷰 계층에 접근한다면 예상치못한 에러가 발생할 수 있다.
- lifecycleOwner는 Fragment 자체의 생명주기를, viewLifecycleOwner는 Fragment 뷰 계층의 생명주기를 나태낸다.


