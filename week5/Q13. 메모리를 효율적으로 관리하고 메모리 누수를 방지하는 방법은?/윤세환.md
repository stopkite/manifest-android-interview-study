### 메모리 관리 방법
- dalvik 또는 ART에서 GC를 사용하여 더 이상 참조하지 않는 객체를 해제한다.
- 또란 안드로이드 시스템에서는 시스템 메모리가 부족할 때 포그라운드 애플리케이션을 우선시하여 백그라운드 프로세스를 종료하기 위해 low-memory killer를 사용한다.

### 메모리 누수를 피하기 위한 모범 사례
- 생명주기를 인지하는 컴포넌트 사용
- Context에 대한 오랜 참조 피하기
- 리스너 및 콜백 등록시 이를 올바르게 해제하기
- 중요하지 않은 객체는 WeakReference 사용하기 (임시 캐시 로직 구현시 유용)
- 누수 감지 툴 사용
- View에 대한 정적 참조 피하기
- 리소스 닫기

### Q. 안드로이드 애플리케이션에서 메모리 누수의 일반적인 원인은 무엇이며, 이를 사전에 방지하기 위한 방법에는 어떤 것들이 있나요?
- 일반적으로 더 이상 사용하지 않은 객체 참조를 유지함으로써 GC가 해당 객체를 해제하지 못하는 것이 원인 중 하나
    - 더 이상 사용하지 않은 Activity, Fragment의 Context를 참조하고 있는 경우
- 이를 방지하기 위해서는 Activity, Fragment의 생명주기를 이해하고 해당 생명주기에 맞춰 사용함과 동시에 ViewModel과 같이 Activity, Fragment보다 생명주기가 더 긴 객체에서 Context를 참조하지 않도록 해야 한다.
- 또한 등록한 리스너를 해제하지 않거나 파일 스트림과 같이 명시적으로 close와 같은 해제 메서드를 호출해야 하지만 하지 않을 경우에도 메모리 누수가 발생할 수 있다.

### Q. 안드로이드의 가비지 컬렉션 메커니즘은 어떻게 작동하며, 개발자는 앱에서 메모리 누수를 감지하고 수정하기 위해 어떤 방법을 사용할 수 있나요?
- Dalvik의 경우, Stop-The-World 형식으로 GC가 수행되는데, 이로 인해 GC가 동작하는 동안에는 모든 애플리케이션 스레드가 중단되어 UI 지연이 발생하는 경우에 존재한다.
GC방식은 Mark-Sweep 알고리즘을 사용한다.
- ART에서는 전체 Heap 영역을 GC 대상으로 하는 방법이 아닌, HEAP 영역을 YG/OG 영역으로 나눈다.
    - YG는 단기간에 생성 및 소멸되는 객체들이 존재하여 Minor GC가 수행된다.
    eden/survivor 영역으로 구분된다.
    Minor GC는 Copying Collector 알고리즘을 사용한다.
    - OG의 경우 장기간동안 유지된(YG 영역에서 일정 횟수 이상 생존) 객체들이 존재하는 영역으로 Major GC가 수행된다.
    Major GC는 Dalvik과 동일한 Mark-Sweep 알고리즘을 사용한다.
- 메모리 누수를 감지하기 위해 Android Studio에서 제공하는 Memory Profiler를 사용하거나 Leak Canary 라이브러리를 사용할 수 있다.